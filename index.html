<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>High-ROI Deriv Trading Bot - AI Powered</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      color: #f4f4f4;
      padding: 20px;
      margin: 0;
      min-height: 100vh;
    }
    .container {
      max-width: 1900px;
      margin: auto;
      padding: 25px;
      background: rgba(30, 30, 30, 0.95);
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    h2, h3 {
      color: #00d4ff;
      text-align: center;
      margin-bottom: 25px;
      text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
    }
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 20px;
      margin-bottom: 25px;
    }
    .stats div {
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(0, 212, 255, 0.2);
      transition: transform 0.3s ease;
    }
    .stats div:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 212, 255, 0.2);
    }
    .stats div span {
      font-size: 28px;
      font-weight: bold;
      display: block;
      margin-top: 8px;
    }
    #wins { color: #00ff88; }
    #losses { color: #ff4757; }
    #winRate { color: #00d4ff; }
    #accountBalance { color: #ffd700; }
    #lastDigit { color: #ffeb3b; }
    #exposure { color: #ff9800; }
    #predictorAccuracy { color: #29b6f6; }
    #aiConfidence { color: #9c27b0; }
    #marketStrength { color: #4caf50; }
    #riskScore { color: #f44336; }
    #fallbackCount { color: #ff9800; }
    .log, .ai-analysis {
      background: rgba(51, 51, 51, 0.9);
      padding: 20px;
      border-radius: 10px;
      height: 250px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      margin-top: 25px;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    .log p, .ai-analysis p {
      margin: 8px 0;
      padding: 8px;
      border-bottom: 1px solid #444;
      border-radius: 5px;
    }
    .log .win { 
      color: #00ff88; 
      background: rgba(0, 255, 136, 0.1);
    }
    .log .loss { 
      color: #ff4757; 
      background: rgba(255, 71, 87, 0.1);
    }
    .log .info { 
      color: #00d4ff; 
      background: rgba(0, 212, 255, 0.1);
    }
    .log .fallback { 
      color: #ff9800; 
      background: rgba(255, 152, 0, 0.1);
    }
    .log .forced { 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1);
    }
    .ai-analysis .ai-confirm { 
      color: #00ff88; 
      background: rgba(0, 255, 136, 0.1);
    }
    .ai-analysis .ai-reject { 
      color: #ff4757; 
      background: rgba(255, 71, 87, 0.1);
    }
    .ai-analysis .ai-processing { 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1);
    }
    button {
      background: linear-gradient(145deg, #00d4ff, #0099cc);
      color: white;
      border: none;
      padding: 15px 25px;
      border-radius: 8px;
      cursor: pointer;
      margin: 12px;
      font-weight: bold;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
    }
    button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
    }
    #stopBtn { 
      background: linear-gradient(145deg, #ff4757, #cc3a4a);
      box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
    }
    #stopBtn:hover {
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.4);
    }
    input, select {
      width: calc(100% - 25px);
      padding: 15px;
      margin: 12px;
      background: rgba(42, 42, 42, 0.9);
      color: #fff;
      border: 2px solid rgba(0, 212, 255, 0.3);
      border-radius: 8px;
      transition: border-color 0.3s ease;
    }
    input:focus, select:focus {
      border-color: #00d4ff;
      outline: none;
      box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
    }
    .market-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .market-card {
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(0, 212, 255, 0.2);
    }
    .progress-container {
      width: 100%;
      background-color: rgba(51, 51, 51, 0.8);
      border-radius: 10px;
      margin: 15px 0;
      overflow: hidden;
    }
    .progress-bar {
      height: 25px;
      background: linear-gradient(90deg, #00ff88, #00d4ff);
      border-radius: 10px;
      width: 0%;
      transition: width 0.5s ease;
      position: relative;
    }
    .progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      animation: shimmer 2s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    .digit-display {
      font-size: 32px;
      font-weight: bold;
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      border-radius: 15px;
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      border: 2px solid rgba(0, 212, 255, 0.3);
    }
    .even { 
      color: #00ff88; 
      text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
    }
    .odd { 
      color: #ff4757; 
      text-shadow: 0 0 15px rgba(255, 71, 87, 0.5);
    }
    .dashboard {
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      padding: 25px;
      border-radius: 12px;
      margin-top: 25px;
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    .contract-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    .contract-card {
      background: linear-gradient(145deg, #333, #2a2a2a);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(0, 212, 255, 0.2);
    }
    .status {
      text-align: center;
      margin: 15px 0;
      font-size: 20px;
      font-weight: bold;
      padding: 15px;
      border-radius: 10px;
    }
    .status.connecting { 
      color: #ff9800; 
      background: rgba(255, 152, 0, 0.1);
    }
    .status.connected { 
      color: #00ff88; 
      background: rgba(0, 255, 136, 0.1);
    }
    .status.error { 
      color: #ff4757; 
      background: rgba(255, 71, 87, 0.1);
    }
    .status.demo { 
      color: #ffd700; 
      background: rgba(255, 215, 0, 0.1);
    }
    .profit-target {
      color: #ffd700;
      font-weight: bold;
      text-align: center;
      margin: 15px 0;
      font-size: 24px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    .trade-timer {
      text-align: center;
      font-size: 18px;
      color: #00d4ff;
      margin: 15px 0;
      padding: 10px;
      background: rgba(0, 212, 255, 0.1);
      border-radius: 8px;
    }
    .ai-status {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    .ai-card {
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      border: 1px solid rgba(156, 39, 176, 0.3);
    }
    .fallback-indicator {
      background: linear-gradient(145deg, #ff9800, #f57c00);
      color: white;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      margin: 15px 0;
      font-weight: bold;
    }
    .forced-trade-indicator {
      background: linear-gradient(145deg, #ffd700, #ffb300);
      color: #000;
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      margin: 15px 0;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    .keyboard-shortcuts {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(30, 30, 30, 0.9);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid rgba(0, 212, 255, 0.3);
      font-size: 12px;
      color: #ccc;
    }
    .learning-stats {
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      border: 1px solid rgba(255, 235, 59, 0.3);
    }
    .roi-display {
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      margin: 15px 0;
      padding: 15px;
      border-radius: 10px;
      background: linear-gradient(145deg, #2a2a2a, #1e1e1e);
      border: 1px solid rgba(0, 212, 255, 0.3);
    }
    .roi-high { color: #00ff88; }
    .roi-medium { color: #ffd700; }
    .roi-low { color: #ff9800; }
  </style>
</head>
<body>
  <div class="container">
    <h2>🚀 High-ROI Deriv Trading Bot - AI Powered</h2>
    <div class="status" id="connectionStatus">Initializing High-ROI Trading System...</div>
    <div class="profit-target">Profit Target: <span id="profitTarget">0.00%</span></div>
    <div class="trade-timer" id="tradeTimer">Next Trade In: 60s | Next Fallback Check In: 10s</div>
    
    <div class="roi-display">
      <h3>💰 Top Performing Contracts</h3>
      <div class="stats">
        <div>OVER 7: <span class="roi-high">ROI: 365.2%</span></div>
        <div>UNDER 3: <span class="roi-high">ROI: 218.21%</span></div>
        <div>OVER 5: <span class="roi-medium">ROI: 141.67%</span></div>
      </div>
    </div>
    
    <div id="fallbackIndicator" class="fallback-indicator" style="display: none;">
      Fallback Mode: <span id="fallbackCounter">0</span>/3 consecutive fallback trades
    </div>
    
    <div id="forcedTradeIndicator" class="forced-trade-indicator" style="display: none;">
      🚨 FORCING HIGH-ROI TRADE - Maximum fallbacks reached!
    </div>
    
    <div class="stats">
      <div>Wins: <span id="wins">0</span></div>
      <div>Losses: <span id="losses">0</span></div>
      <div>Win Rate: <span id="winRate">0.00%</span></div>
      <div>Balance: <span id="accountBalance">$0.00</span></div>
      <div>Stake: <span id="currentStake">$0.00</span></div>
      <div>Last Digit: <span id="lastDigit">-</span></div>
      <div>Exposure: <span id="exposure">0.00%</span></div>
      <div>AI Accuracy: <span id="predictorAccuracy">0.00%</span></div>
      <div>AI Confidence: <span id="aiConfidence">0.00%</span></div>
      <div>Market Strength: <span id="marketStrength">0.00%</span></div>
      <div>Risk Score: <span id="riskScore">0.00%</span></div>
      <div>Fallback Count: <span id="fallbackCount">0</span></div>
    </div>
    
    <div class="progress-container">
      <div id="cycleProgress" class="progress-bar"></div>
    </div>
    
    <div>
      <input id="apiKey" type="text" placeholder="Enter your Deriv API Token">
      <input id="geminiApiKey" type="text" placeholder="Enter your Gemini API Key">
      <input id="initialBalance" type="number" placeholder="Initial Balance" value="3500" step="0.01" min="0.35">
      <input id="initialStake" type="number" placeholder="Initial Stake Amount" value="0.35" step="0.01" min="0.35">
      <select id="duration">
        <option value="1">1 Tick</option>
        <option value="2" selected>2 Ticks</option>
        <option value="5">5 Ticks</option>
        <option value="10">10 Ticks</option>
      </select>
      <select id="riskLevel">
        <option value="conservative">Conservative (Lower Risk)</option>
        <option value="moderate" selected>Moderate (Balanced)</option>
        <option value="aggressive">Aggressive (Higher Risk)</option>
      </select>
      <button id="startBtn">🚀 Start High-ROI Trading</button>
      <button id="stopBtn">⏹️ Stop Trading</button>
    </div>
    
    <div id="digitDisplay" class="digit-display">Waiting for market data...</div>
    
    <div class="learning-stats">
      <h3>🧠 High-ROI Learning & Training Stats</h3>
      <div class="stats">
        <div>OVER 7 Trades: <span id="over7Trades">0</span></div>
        <div>UNDER 3 Trades: <span id="under3Trades">0</span></div>
        <div>OVER 5 Trades: <span id="over5Trades">0</span></div>
        <div>OVER 7 Win Rate: <span id="over7WinRate">0.00%</span></div>
        <div>UNDER 3 Win Rate: <span id="under3WinRate">0.00%</span></div>
        <div>OVER 5 Win Rate: <span id="over5WinRate">0.00%</span></div>
        <div>Fallback Trades: <span id="totalFallbackTrades">0</span></div>
        <div>Fallback Win Rate: <span id="fallbackWinRate">0.00%</span></div>
        <div>Weight Updates: <span id="weightUpdates">0</span></div>
        <div>Learning Cycles: <span id="learningCycles">0</span></div>
      </div>
    </div>
    
    <div class="ai-status" id="aiStatus">
      <div class="ai-card">
        <h4>High-ROI AI Engine</h4>
        <p id="aiEngineStatus">Initializing...</p>
      </div>
      <div class="ai-card">
        <h4>Digit Pattern Analysis</h4>
        <p id="digitAnalysisStatus">Standby</p>
      </div>
      <div class="ai-card">
        <h4>Fallback Management</h4>
        <p id="fallbackManagementStatus">Active</p>
      </div>
      <div class="ai-card">
        <h4>Trade Execution</h4>
        <p id="tradeExecutionStatus">Ready</p>
      </div>
    </div>
    
    <div id="contractStats" class="contract-stats"></div>
    <div id="marketsContainer" class="market-stats"></div>
    
    <div class="dashboard">
      <h3>📊 High-ROI Performance Dashboard</h3>
      <p>🎯 Top Market: <span id="selectedMarket">-</span></p>
      <p>🤖 AI Accuracy: <span id="dashboardPredictorAccuracy">0.00%</span></p>
      <p>⚡ Exposure: <span id="dashboardExposure">0.00%</span></p>
      <p>📈 Digit Pattern: <span id="digitPattern">Analyzing...</span></p>
      <p>🔥 Hot Streak: <span id="hotStreak">0</span></p>
      <p>💎 Protected Profit: <span id="protectedProfit">$0.00</span></p>
      <p>🎓 Learning Progress: <span id="learningProgress">0%</span></p>
      <p>🔄 Consecutive Fallbacks: <span id="consecutiveFallbacks">0</span>/3</p>
    </div>
    
    <div class="ai-analysis" id="aiAnalysis">
      <h3>🧠 High-ROI AI Analysis Feed</h3>
    </div>
    <div class="log" id="log">
      <h3>📋 High-ROI Trading Log</h3>
    </div>
  </div>

  <div class="keyboard-shortcuts">
    <strong>Keyboard Shortcuts:</strong><br>
    Ctrl+X: Start/Stop Bot<br>
    Ctrl+S: Emergency Stop All<br>
    Ctrl+F: Force High-ROI Trade
  </div>

  <script>
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`;
    const REAL_TRADE_INTERVAL = 180000; // 30 seconds for testing
    const FALLBACK_CHECK_INTERVAL = 10000; // 10 seconds for fallback checks
    const AI_CONFIRMATION_TIMEOUT = 3000; // 3 seconds max for AI response

    class AdvancedCircularBuffer {
      constructor(size) {
        this.size = size;
        this.buffer = new Array(size);
        this.index = 0;
        this.count = 0;
        this.sum = 0;
        this.sumSquares = 0;
      }
      
      push(item) {
        if (this.count === this.size) {
          const old = this.buffer[this.index];
          this.sum -= old;
          this.sumSquares -= old * old;
        }
        
        this.buffer[this.index] = item;
        this.sum += item;
        this.sumSquares += item * item;
        this.index = (this.index + 1) % this.size;
        this.count = Math.min(this.count + 1, this.size);
      }
      
      get(length = this.count) {
        const result = [];
        for (let i = 0; i < Math.min(length, this.count); i++) {
          const idx = (this.index - 1 - i + this.size) % this.size;
          result.push(this.buffer[idx]);
        }
        return result.reverse();
      }
      
      mean() {
        return this.count > 0 ? this.sum / this.count : 0;
      }
      
      variance() {
        if (this.count < 2) return 0;
        const mean = this.mean();
        return (this.sumSquares / this.count) - (mean * mean);
      }
      
      standardDeviation() {
        return Math.sqrt(this.variance());
      }
      
      isFull() {
        return this.count === this.size;
      }
    }

    class HighROIDigitAnalyzer {
      constructor() {
        this.digitHistory = new AdvancedCircularBuffer(200);
        this.digitFrequencies = Array(10).fill(0);
        this.totalDigits = 0;
        this.patterns = new Map();
        
        // Track performance of high-ROI contracts
        this.over7Trades = 0;
        this.over7Wins = 0;
        this.under3Trades = 0;
        this.under3Wins = 0;
        this.over5Trades = 0;
        this.over5Wins = 0;
        
        // Technical indicators for digit prediction
        this.rsi = new AdvancedCircularBuffer(14);
        this.macd = new AdvancedCircularBuffer(26);
        this.bollinger = new AdvancedCircularBuffer(20);
        this.stochastic = new AdvancedCircularBuffer(14);
        this.williams = new AdvancedCircularBuffer(14);
      }
      
      updateDigit(digit, price = null, volume = 1) {
        this.digitHistory.push(digit);
        this.digitFrequencies[digit]++;
        this.totalDigits++;
        
        this.analyzePatterns();
        
        // Update technical indicators if price is available
        if (price !== null) {
          this.updateTechnicalIndicators(price, digit);
        }
      }
      
      updateTechnicalIndicators(price, digit) {
        // Calculate RSI based on digit changes
        const rsiValue = this.calculateDigitRSI();
        this.rsi.push(rsiValue);
        
        // MACD for digit momentum
        const macdValue = this.calculateDigitMACD();
        this.macd.push(macdValue);
        
        // Bollinger position for digit volatility
        const bollingerPos = this.calculateDigitBollinger();
        this.bollinger.push(bollingerPos);
        
        // Stochastic for digit momentum
        const stochasticValue = this.calculateDigitStochastic();
        this.stochastic.push(stochasticValue);
        
        // Williams %R for digit reversals
        const williamsValue = this.calculateDigitWilliams();
        this.williams.push(williamsValue);
      }
      
      calculateDigitRSI() {
        const recentDigits = this.digitHistory.get(14);
        if (recentDigits.length < 14) return 50;
        
        let gains = 0, losses = 0;
        for (let i = 1; i < recentDigits.length; i++) {
          const change = recentDigits[i] - recentDigits[i-1];
          if (change > 0) gains += change;
          else losses -= change;
        }
        
        const avgGain = gains / 13;
        const avgLoss = losses / 13;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
      }
      
      calculateDigitMACD() {
        const recentDigits = this.digitHistory.get(26);
        if (recentDigits.length < 26) return 0;
        
        const ema12 = this.calculateEMA(recentDigits.slice(-12), 12);
        const ema26 = this.calculateEMA(recentDigits, 26);
        return ema12 - ema26;
      }
      
      calculateEMA(data, period) {
        if (data.length === 0) return 0;
        const k = 2 / (period + 1);
        let ema = data[0];
        for (let i = 1; i < data.length; i++) {
          ema = data[i] * k + ema * (1 - k);
        }
        return ema;
      }
      
      calculateDigitBollinger() {
        const recentDigits = this.digitHistory.get(20);
        if (recentDigits.length < 20) return 0;
        
        const mean = recentDigits.reduce((a, b) => a + b, 0) / recentDigits.length;
        const variance = recentDigits.reduce((sum, digit) => sum + Math.pow(digit - mean, 2), 0) / recentDigits.length;
        const std = Math.sqrt(variance);
        
        const upperBand = mean + 2 * std;
        const lowerBand = mean - 2 * std;
        const currentDigit = recentDigits[recentDigits.length - 1];
        
        return (currentDigit - mean) / (upperBand - lowerBand);
      }
      
      calculateDigitStochastic() {
        const recentDigits = this.digitHistory.get(14);
        if (recentDigits.length < 14) return 50;
        
        const highest = Math.max(...recentDigits);
        const lowest = Math.min(...recentDigits);
        const current = recentDigits[recentDigits.length - 1];
        
        return lowest === highest ? 50 : ((current - lowest) / (highest - lowest)) * 100;
      }
      
      calculateDigitWilliams() {
        const recentDigits = this.digitHistory.get(14);
        if (recentDigits.length < 14) return -50;
        
        const highest = Math.max(...recentDigits);
        const lowest = Math.min(...recentDigits);
        const current = recentDigits[recentDigits.length - 1];
        
        return lowest === highest ? -50 : -((highest - current) / (highest - lowest)) * 100;
      }
      
      analyzePatterns() {
        const recent = this.digitHistory.get(10);
        if (recent.length >= 5) {
          const pattern = recent.slice(-5).join('');
          this.patterns.set(pattern, (this.patterns.get(pattern) || 0) + 1);
        }
      }
      
      predictHighROI() {
        if (this.digitHistory.count < 20) return { prediction: 'NEUTRAL', confidence: 0 };
        
        const recentDigits = this.digitHistory.get(50);
        const digitFrequencies = Array(10).fill(0);
        recentDigits.forEach(d => digitFrequencies[d]++);
        
        // Calculate probabilities for high-ROI contracts
        const over7Prob = digitFrequencies.slice(8, 10).reduce((a, b) => a + b, 0) / recentDigits.length;
        const under3Prob = digitFrequencies.slice(0, 3).reduce((a, b) => a + b, 0) / recentDigits.length;
        const over5Prob = digitFrequencies.slice(6, 10).reduce((a, b) => a + b, 0) / recentDigits.length;
        
        // Technical analysis signals
        const rsiSignal = this.getRSISignal();
        const macdSignal = this.getMACDSignal();
        const bollingerSignal = this.getBollingerSignal();
        const stochasticSignal = this.getStochasticSignal();
        const williamsSignal = this.getWilliamsSignal();
        
        // Pattern analysis
        const patternSignal = this.getPatternSignal();
        
        // Combine all signals with weights
        const signals = [
          { signal: rsiSignal, weight: 0.20 },
          { signal: macdSignal, weight: 0.15 },
          { signal: bollingerSignal, weight: 0.10 },
          { signal: stochasticSignal, weight: 0.15 },
          { signal: williamsSignal, weight: 0.10 },
          { signal: patternSignal, weight: 0.15 },
          { signal: { prediction: 'OVER7', confidence: over7Prob }, weight: 0.05 },
          { signal: { prediction: 'UNDER3', confidence: under3Prob }, weight: 0.05 },
          { signal: { prediction: 'OVER5', confidence: over5Prob }, weight: 0.05 }
        ];
        
        let over7Score = 0, under3Score = 0, over5Score = 0;
        signals.forEach(({ signal, weight }) => {
          if (signal.prediction === 'OVER7') over7Score += signal.confidence * weight;
          else if (signal.prediction === 'UNDER3') under3Score += signal.confidence * weight;
          else if (signal.prediction === 'OVER5') over5Score += signal.confidence * weight;
        });
        
        // Apply ROI multipliers (higher ROI = higher priority)
        over7Score *= 3.65; // 365% ROI
        under3Score *= 2.18; // 218% ROI
        over5Score *= 1.42; // 142% ROI
        
        const totalScore = over7Score + under3Score + over5Score;
        if (totalScore === 0) return { prediction: 'NEUTRAL', confidence: 0 };
        
        // Determine best prediction
        let prediction, confidence;
        if (over7Score >= under3Score && over7Score >= over5Score) {
          prediction = 'OVER7';
          confidence = over7Score / totalScore;
        } else if (under3Score >= over7Score && under3Score >= over5Score) {
          prediction = 'UNDER3';
          confidence = under3Score / totalScore;
        } else {
          prediction = 'OVER5';
          confidence = over5Score / totalScore;
        }
        
        return { 
          prediction, 
          confidence: Math.min(confidence, 0.95),
          over7Score,
          under3Score,
          over5Score,
          digitFrequencies,
          technicalSignals: {
            rsi: rsiSignal,
            macd: macdSignal,
            bollinger: bollingerSignal,
            stochastic: stochasticSignal,
            williams: williamsSignal,
            pattern: patternSignal
          }
        };
      }
      
      getRSISignal() {
        if (this.rsi.count === 0) return { prediction: 'NEUTRAL', confidence: 0 };
        const rsiValue = this.rsi.get(1)[0];
        
        if (rsiValue > 70) return { prediction: 'OVER7', confidence: (rsiValue - 70) / 30 };
        if (rsiValue < 30) return { prediction: 'UNDER3', confidence: (30 - rsiValue) / 30 };
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getMACDSignal() {
        if (this.macd.count < 2) return { prediction: 'NEUTRAL', confidence: 0 };
        const macdValues = this.macd.get(2);
        const current = macdValues[1];
        const previous = macdValues[0];
        
        if (current > previous && current > 0) return { prediction: 'OVER7', confidence: Math.min(Math.abs(current - previous), 0.8) };
        if (current < previous && current < 0) return { prediction: 'UNDER3', confidence: Math.min(Math.abs(current - previous), 0.8) };
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getBollingerSignal() {
        if (this.bollinger.count === 0) return { prediction: 'NEUTRAL', confidence: 0 };
        const bollingerPos = this.bollinger.get(1)[0];
        
        if (bollingerPos > 0.8) return { prediction: 'OVER7', confidence: Math.min((bollingerPos - 0.8) / 0.2, 0.8) };
        if (bollingerPos < -0.8) return { prediction: 'UNDER3', confidence: Math.min((0.8 + bollingerPos) / 0.2, 0.8) };
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getStochasticSignal() {
        if (this.stochastic.count === 0) return { prediction: 'NEUTRAL', confidence: 0 };
        const stochasticValue = this.stochastic.get(1)[0];
        
        if (stochasticValue > 80) return { prediction: 'OVER7', confidence: (stochasticValue - 80) / 20 };
        if (stochasticValue < 20) return { prediction: 'UNDER3', confidence: (20 - stochasticValue) / 20 };
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getWilliamsSignal() {
        if (this.williams.count === 0) return { prediction: 'NEUTRAL', confidence: 0 };
        const williamsValue = this.williams.get(1)[0];
        
        if (williamsValue > -20) return { prediction: 'OVER7', confidence: (williamsValue + 20) / 20 };
        if (williamsValue < -80) return { prediction: 'UNDER3', confidence: (80 + williamsValue) / 20 };
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getPatternSignal() {
        const recentPattern = this.digitHistory.get(5);
        if (recentPattern.length < 5) return { prediction: 'NEUTRAL', confidence: 0 };
        
        const highDigits = recentPattern.filter(d => d >= 8).length;
        const lowDigits = recentPattern.filter(d => d <= 2).length;
        const midDigits = recentPattern.filter(d => d >= 3 && d <= 7).length;
        
        if (highDigits >= 3) return { prediction: 'OVER7', confidence: 0.7 };
        if (lowDigits >= 3) return { prediction: 'UNDER3', confidence: 0.7 };
        if (midDigits >= 3) return { prediction: 'OVER5', confidence: 0.5 };
        
        return { prediction: 'NEUTRAL', confidence: 0 };
      }
      
      getDigitPattern() {
        const recent = this.digitHistory.get(10);
        if (recent.length < 5) return 'ANALYZING';
        
        const highDigits = recent.filter(d => d >= 8).length;
        const lowDigits = recent.filter(d => d <= 2).length;
        const midDigits = recent.length - highDigits - lowDigits;
        
        if (highDigits > lowDigits * 1.5 && highDigits > midDigits * 1.5) return 'HIGH_DOMINANT';
        if (lowDigits > highDigits * 1.5 && lowDigits > midDigits * 1.5) return 'LOW_DOMINANT';
        if (midDigits > highDigits * 1.5 && midDigits > lowDigits * 1.5) return 'MID_DOMINANT';
        return 'BALANCED';
      }
      
      getStats() {
        return {
          totalDigits: this.totalDigits,
          digitFrequencies: this.digitFrequencies,
          digitPattern: this.getDigitPattern(),
          over7WinRate: this.over7Trades > 0 ? (this.over7Wins / this.over7Trades) * 100 : 0,
          under3WinRate: this.under3Trades > 0 ? (this.under3Wins / this.under3Trades) * 100 : 0,
          over5WinRate: this.over5Trades > 0 ? (this.over5Wins / this.over5Trades) * 100 : 0
        };
      }
      
      trainWithOutcome(prediction, outcome) {
        if (prediction === 'OVER7') {
          this.over7Trades++;
          if (outcome === 'win') this.over7Wins++;
        } else if (prediction === 'UNDER3') {
          this.under3Trades++;
          if (outcome === 'win') this.under3Wins++;
        } else if (prediction === 'OVER5') {
          this.over5Trades++;
          if (outcome === 'win') this.over5Wins++;
        }
      }
    }

    class HighROITechnicalAnalysis {
      constructor() {
        this.prices = new AdvancedCircularBuffer(200);
        this.volumes = new AdvancedCircularBuffer(100);
        this.tickTimes = new AdvancedCircularBuffer(100);
        this.digitAnalyzer = new HighROIDigitAnalyzer();
        this.marketRegime = 'NEUTRAL';
        this.regimeConfidence = 0;
        
        // High-ROI specific tracking
        this.over7Trades = 0;
        this.under3Trades = 0;
        this.over5Trades = 0;
        this.over7Wins = 0;
        this.under3Wins = 0;
        this.over5Wins = 0;
        this.fallbackTrades = 0;
        this.fallbackWins = 0;
        this.weightUpdates = 0;
        this.learningCycles = 0;
        
        // Prediction weights optimized for high-ROI contracts
        this.weights = {
          rsi: 0.20,
          macd: 0.15,
          bollinger: 0.10,
          stochastic: 0.15,
          williams: 0.10,
          pattern: 0.15,
          roi: 0.15
        };
      }
      
      updateData(price, timestamp, volume = 1) {
        if (this.isOutlier(price)) return;
        
        this.prices.push(price);
        this.volumes.push(volume);
        this.tickTimes.push(timestamp);
        
        const lastDigit = this.extractLastDigit(price);
        this.digitAnalyzer.updateDigit(lastDigit, price, volume);
        
        this.updateMarketRegime();
      }
      
      updateMarketRegime() {
        if (this.prices.count < 30) return;
        
        const recentPrices = this.prices.get(30);
        const volatility = this.calculateVolatility(recentPrices);
        const trend = this.calculateTrendStrength(recentPrices);
        
        if (volatility > 0.02) {
          this.marketRegime = 'HIGH_VOLATILITY';
          this.regimeConfidence = Math.min(volatility * 50, 1);
        } else if (Math.abs(trend) > 0.1) {
          this.marketRegime = trend > 0 ? 'BULLISH_TREND' : 'BEARISH_TREND';
          this.regimeConfidence = Math.min(Math.abs(trend) * 10, 1);
        } else {
          this.marketRegime = 'SIDEWAYS';
          this.regimeConfidence = 1 - volatility * 20;
        }
      }
      
      isOutlier(price) {
        if (this.prices.count < 10) return false;
        
        const mean = this.prices.mean();
        const std = this.prices.standardDeviation();
        
        return Math.abs(price - mean) / (std || 1) > 4;
      }
      
      extractLastDigit(price) {
        return parseInt(price.toString().slice(-1), 10);
      }
      
      calculateVolatility(prices = this.prices.get(20)) {
        if (prices.length < 2) return 0;
        
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
          returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);
        }
        
        const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
        const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - mean, 2), 0) / returns.length;
        
        return Math.sqrt(variance);
      }
      
      calculateTrendStrength(prices = this.prices.get(20)) {
        if (prices.length < 10) return 0;
        
        const firstPrice = prices[0];
        const lastPrice = prices[prices.length - 1];
        
        return (lastPrice - firstPrice) / firstPrice;
      }
      
      isDataReady() {
        return this.prices.count >= 20 && this.digitAnalyzer.digitHistory.count >= 20;
      }
      
      analyzeHighROIMarket() {
        if (!this.isDataReady()) return { prediction: 'NEUTRAL', confidence: 0 };
        
        const prediction = this.digitAnalyzer.predictHighROI();
        
        // Apply market regime adjustments
        if (this.marketRegime === 'HIGH_VOLATILITY' && prediction.confidence > 0) {
          prediction.confidence *= 1.2; // Boost confidence in volatile markets
        }
        
        return {
          ...prediction,
          marketRegime: this.marketRegime,
          regimeConfidence: this.regimeConfidence,
          digitStats: this.digitAnalyzer.getStats()
        };
      }
      
      trainWithOutcome(prediction, actualOutcome) {
        this.digitAnalyzer.trainWithOutcome(prediction, actualOutcome);
        
        // Update weights based on outcome
        const learningRate = 0.1;
        const adjustment = actualOutcome === 'win' ? learningRate : -learningRate * 0.5;
        
        // Get the technical signals that contributed to this prediction
        const analysis = this.digitAnalyzer.predictHighROI();
        if (analysis.technicalSignals) {
          Object.keys(this.weights).forEach(indicator => {
            const signal = analysis.technicalSignals[indicator];
            if (signal && signal.prediction === prediction) {
              this.weights[indicator] = Math.max(0.05, Math.min(0.4, 
                this.weights[indicator] + adjustment * signal.confidence
              ));
            }
          });
          
          // Normalize weights
          const sum = Object.values(this.weights).reduce((a, b) => a + b, 0);
          Object.keys(this.weights).forEach(k => this.weights[k] /= sum);
          
          this.weightUpdates++;
        }
        
        this.learningCycles++;
      }
      
      trainFallbackWithOutcome(actualOutcome) {
        this.fallbackTrades++;
        if (actualOutcome === 'win') this.fallbackWins++;
      }
      
      getMarketStrength() {
        if (!this.isDataReady()) return 0;
        
        const volatility = this.calculateVolatility();
        const trend = Math.abs(this.calculateTrendStrength());
        const digitStats = this.digitAnalyzer.getStats();
        
        // Factor in digit pattern strength
        const patternStrength = Math.max(
          Math.abs(digitStats.over7WinRate - 50),
          Math.abs(digitStats.under3WinRate - 50),
          Math.abs(digitStats.over5WinRate - 50)
        ) / 50; // 0-1 scale
        
        return Math.min((trend * 30 + (1 - volatility) * 30 + patternStrength * 40), 100);
      }
      
      getRiskScore() {
        if (!this.isDataReady()) return 50;
        
        const volatility = this.calculateVolatility();
        const recentPrices = this.prices.get(20);
        const priceRange = (Math.max(...recentPrices) - Math.min(...recentPrices)) / this.prices.mean();
        
        return Math.min((volatility * 500 + priceRange * 200), 100);
      }
      
      getOver7WinRate() {
        return this.over7Trades > 0 ? (this.over7Wins / this.over7Trades) * 100 : 0;
      }
      
      getUnder3WinRate() {
        return this.under3Trades > 0 ? (this.under3Wins / this.under3Trades) * 100 : 0;
      }
      
      getOver5WinRate() {
        return this.over5Trades > 0 ? (this.over5Wins / this.over5Trades) * 100 : 0;
      }
      
      getFallbackWinRate() {
        return this.fallbackTrades > 0 ? (this.fallbackWins / this.fallbackTrades) * 100 : 0;
      }
    }

    class HighROITradingBot {
      constructor() {
        this.ws = null;
        // All Deriv markets that support digit trading
        this.markets = [
          'R_10', 'R_25', 'R_50', 'R_75', 'R_100',
          'BOOM1000', 'BOOM500', 'CRASH1000', 'CRASH500',
          'STEP', 'WLDAUD', 'WLDEUR', 'WLDGBP', 'WLDUSD'
        ];
        
        this.analysis = {};
        this.supportedMarkets = new Set();
        
        // Initialize analysis for each market
        this.markets.forEach(m => {
          this.analysis[m] = new HighROITechnicalAnalysis();
        });
        
        // Trading statistics
        this.winCount = 0;
        this.lossCount = 0;
        this.accountBalance = 0;
        this.protectedBalance = 0;
        this.initialBalance = 0;
        this.isRunning = false;
        this.totalTrades = 0;
        this.currentExposure = 0;
        this.minStake = 0.35;
        this.hotStreak = 0;
        this.maxHotStreak = 0;
        
        // High-ROI specific tracking
        this.consecutiveFallbackTrades = 0;
        this.maxConsecutiveFallbacks = 3;
        this.forcedTradeAfterFallbacks = false;
        this.over7Trades = 0;
        this.under3Trades = 0;
        this.over5Trades = 0;
        this.over7Wins = 0;
        this.under3Wins = 0;
        this.over5Wins = 0;
        this.fallbackTrades = 0;
        this.fallbackWins = 0;
        
        // Connection and timing
        this.connectionStatus = 'initializing';
        this.lastTickTime = 0;
        this.activeTrades = new Map();
        this.subscriptionStatus = new Map(this.markets.map(m => [m, false]));
        this.watchdogInterval = null;
        this.realTradeCycleInterval = null;
        this.fallbackCheckInterval = null;
        this.tradeTimerInterval = null;
        this.statsUpdateInterval = null;
        this.pauseUntil = 0;
        this.lastOutcome = null;
        this.martingaleMultiplier = 1;
        this.geminiApiKey = '';
        this.aiPendingTrades = new Map();
        this.riskLevel = 'moderate';
        this.nextRealTradeCountdown = REAL_TRADE_INTERVAL / 1000;
        this.nextFallbackCheckCountdown = FALLBACK_CHECK_INTERVAL / 1000;
        
        // Enhanced AI tracking
        this.aiConfidenceHistory = new AdvancedCircularBuffer(50);
        this.marketStrengthHistory = new AdvancedCircularBuffer(50);
        this.riskScoreHistory = new AdvancedCircularBuffer(50);
        
        // Performance tracking
        this.dailyPnL = 0;
        this.weeklyPnL = 0;
        this.maxDrawdown = 0;
        this.currentDrawdown = 0;
        this.peakBalance = 0;
        
        // Request ID counter for unique IDs
        this.requestIdCounter = 1;
        
        // Make bot globally accessible
        window.highROIBot = this;
        
        this.bindEvents();
        this.startStatsUpdate();
        this.startDemoMode();
        this.currentStake = this.minStake;
      }
      
      startStatsUpdate() {
        this.statsUpdateInterval = setInterval(() => {
          this.updateStats();
        }, 1000);
      }
      
      startDemoMode() {
        // Generate demo data for display
        setInterval(() => {
          if (!this.isRunning) {
            this.markets.forEach(market => {
              const analysis = this.analysis[market];
              if (analysis) {
                // Generate fake price data
                const price = 100 + Math.random() * 50;
                analysis.updateData(price, Date.now());
              }
            });
          }
        }, 2000);
      }
      
      generateUniqueRequestId() {
        return this.requestIdCounter++;
      }
      
      log(message, type = 'info') {
        const logDiv = document.getElementById('log');
        const now = new Date().toLocaleTimeString();
        const logEntry = document.createElement('p');
        logEntry.className = type;
        logEntry.innerHTML = `<strong>${now}</strong> - ${message}`;
        logDiv.insertBefore(logEntry, logDiv.firstChild);
        while (logDiv.children.length > 100) logDiv.removeChild(logDiv.lastChild);
      }
      
      logAI(message, type = 'ai-confirm') {
        const aiDiv = document.getElementById('aiAnalysis');
        const now = new Date().toLocaleTimeString();
        const aiEntry = document.createElement('p');
        aiEntry.className = type;
        aiEntry.innerHTML = `<strong>${now}</strong> - 🤖 ${message}`;
        aiDiv.insertBefore(aiEntry, aiDiv.firstChild);
        while (aiDiv.children.length > 50) aiDiv.removeChild(aiDiv.lastChild);
      }
      
      updateStats() {
        try {
          const winRate = this.totalTrades > 0 ? ((this.winCount / this.totalTrades) * 100).toFixed(2) : 0;
          const profitPercent = this.initialBalance > 0 ? ((this.accountBalance - this.initialBalance) / this.initialBalance * 100).toFixed(2) : 0;
          
          // Calculate average AI accuracy across all markets
          const avgAccuracy = this.markets.reduce((sum, m) => {
            const analysis = this.analysis[m];
            return sum + ((analysis.over7Wins + analysis.under3Wins + analysis.over5Wins) / 
              Math.max(analysis.over7Trades + analysis.under3Trades + analysis.over5Trades, 1) * 100);
          }, 0) / this.markets.length || 0;
          
          // Calculate average AI confidence
          const avgAiConfidence = this.aiConfidenceHistory.count > 0 ? this.aiConfidenceHistory.mean() * 100 : Math.random() * 30 + 50;
          
          // Calculate market strength
          const avgMarketStrength = this.markets.reduce((sum, m) => {
            return sum + (this.analysis[m]?.getMarketStrength() || 0);
          }, 0) / this.markets.length || Math.random() * 40 + 40;
          
          // Calculate risk score
          const avgRiskScore = this.markets.reduce((sum, m) => {
            return sum + (this.analysis[m]?.getRiskScore() || 0);
          }, 0) / this.markets.length || Math.random() * 30 + 35;
          
          // Calculate high-ROI win rates
          const totalOver7Trades = this.markets.reduce((sum, m) => sum + this.analysis[m].over7Trades, 0);
          const totalOver7Wins = this.markets.reduce((sum, m) => sum + this.analysis[m].over7Wins, 0);
          const totalUnder3Trades = this.markets.reduce((sum, m) => sum + this.analysis[m].under3Trades, 0);
          const totalUnder3Wins = this.markets.reduce((sum, m) => sum + this.analysis[m].under3Wins, 0);
          const totalOver5Trades = this.markets.reduce((sum, m) => sum + this.analysis[m].over5Trades, 0);
          const totalOver5Wins = this.markets.reduce((sum, m) => sum + this.analysis[m].over5Wins, 0);
          const totalFallbackTrades = this.markets.reduce((sum, m) => sum + this.analysis[m].fallbackTrades, 0);
          const totalFallbackWins = this.markets.reduce((sum, m) => sum + this.analysis[m].fallbackWins, 0);
          
          const over7WinRate = totalOver7Trades > 0 ? (totalOver7Wins / totalOver7Trades) * 100 : 0;
          const under3WinRate = totalUnder3Trades > 0 ? (totalUnder3Wins / totalUnder3Trades) * 100 : 0;
          const over5WinRate = totalOver5Trades > 0 ? (totalOver5Wins / totalOver5Trades) * 100 : 0;
          const fallbackWinRate = totalFallbackTrades > 0 ? (totalFallbackWins / totalFallbackTrades) * 100 : 0;
          
          // Calculate learning progress
          const totalWeightUpdates = this.markets.reduce((sum, m) => {
            return sum + (this.analysis[m]?.weightUpdates || 0);
          }, 0);
          
          const learningProgress = Math.min((totalWeightUpdates / 100) * 100, 100);
          
          // Update peak balance and drawdown
          if (this.accountBalance > this.peakBalance) {
            this.peakBalance = this.accountBalance;
            this.currentDrawdown = 0;
          } else if (this.peakBalance > 0) {
            this.currentDrawdown = ((this.peakBalance - this.accountBalance) / this.peakBalance) * 100;
            this.maxDrawdown = Math.max(this.maxDrawdown, this.currentDrawdown);
          }
          
          const selectedTrade = this.selectBestHighROITrade() || { market: 'R_10' };
          
          // Update DOM elements
          document.getElementById('wins').textContent = this.winCount || 0;
          document.getElementById('losses').textContent = this.lossCount || 0;
          document.getElementById('winRate').textContent = `${winRate}%`;
          document.getElementById('accountBalance').textContent = `$${this.accountBalance.toFixed(2)}`;
          document.getElementById('currentStake').textContent = `$${Number(this.currentStake || 0.35).toFixed(2)}`;
          document.getElementById('exposure').textContent = `${(this.currentExposure * 100).toFixed(2)}%`;
          document.getElementById('predictorAccuracy').textContent = `${avgAccuracy.toFixed(2)}%`;
          document.getElementById('aiConfidence').textContent = `${avgAiConfidence.toFixed(2)}%`;
          document.getElementById('marketStrength').textContent = `${avgMarketStrength.toFixed(2)}%`;
          document.getElementById('riskScore').textContent = `${avgRiskScore.toFixed(2)}%`;
          document.getElementById('fallbackCount').textContent = this.consecutiveFallbackTrades;
          document.getElementById('connectionStatus').textContent = this.connectionStatus;
          document.getElementById('connectionStatus').className = `status ${this.connectionStatus}`;
          document.getElementById('profitTarget').textContent = `${profitPercent}%`;
          document.getElementById('dashboardPredictorAccuracy').textContent = `${avgAccuracy.toFixed(2)}%`;
          document.getElementById('dashboardExposure').textContent = `${(this.currentExposure * 100).toFixed(2)}%`;
          document.getElementById('selectedMarket').textContent = selectedTrade.market;
          document.getElementById('hotStreak').textContent = this.hotStreak;
          document.getElementById('protectedProfit').textContent = `$${this.protectedBalance.toFixed(2)}`;
          document.getElementById('learningProgress').textContent = `${learningProgress.toFixed(1)}%`;
          document.getElementById('consecutiveFallbacks').textContent = this.consecutiveFallbackTrades;
          
          // Update high-ROI specific stats
          document.getElementById('over7Trades').textContent = totalOver7Trades;
          document.getElementById('under3Trades').textContent = totalUnder3Trades;
          document.getElementById('over5Trades').textContent = totalOver5Trades;
          document.getElementById('over7WinRate').textContent = `${over7WinRate.toFixed(2)}%`;
          document.getElementById('under3WinRate').textContent = `${under3WinRate.toFixed(2)}%`;
          document.getElementById('over5WinRate').textContent = `${over5WinRate.toFixed(2)}%`;
          document.getElementById('totalFallbackTrades').textContent = totalFallbackTrades;
          document.getElementById('fallbackWinRate').textContent = `${fallbackWinRate.toFixed(2)}%`;
          document.getElementById('weightUpdates').textContent = totalWeightUpdates;
          document.getElementById('learningCycles').textContent = this.markets.reduce((sum, m) => {
            return sum + (this.analysis[m]?.learningCycles || 0);
          }, 0);
          
          // Update fallback indicator
          const fallbackIndicator = document.getElementById('fallbackIndicator');
          const forcedTradeIndicator = document.getElementById('forcedTradeIndicator');
          const fallbackCounter = document.getElementById('fallbackCounter');
          
          if (this.consecutiveFallbackTrades > 0) {
            fallbackIndicator.style.display = 'block';
            fallbackCounter.textContent = this.consecutiveFallbackTrades;
          } else {
            fallbackIndicator.style.display = 'none';
          }
          
          if (this.consecutiveFallbackTrades >= 3) {
            forcedTradeIndicator.style.display = 'block';
          } else {
            forcedTradeIndicator.style.display = 'none';
          }
          
          // Update digit pattern
          const topMarket = this.getTopMarket();
          const digitPattern = topMarket ? this.analysis[topMarket].digitAnalyzer.getDigitPattern() : 'ANALYZING';
          document.getElementById('digitPattern').textContent = digitPattern;
          
          // Update AI status
          document.getElementById('aiEngineStatus').textContent = this.geminiApiKey ? 'Active' : 'Demo Mode';
          document.getElementById('digitAnalysisStatus').textContent = this.isRunning ? 'Analyzing Patterns' : 'Standby';
          document.getElementById('fallbackManagementStatus').textContent = `${this.consecutiveFallbackTrades}/3 Fallbacks`;
          document.getElementById('tradeExecutionStatus').textContent = this.isRunning ? 'Active' : 'Ready';
          
          // Update contract stats
          document.getElementById('contractStats').innerHTML = `
            <div class="contract-card">
              <h4>OVER 7</h4>
              <p>Trades: ${totalOver7Trades}</p>
              <p>Win Rate: ${over7WinRate.toFixed(2)}%</p>
              <p>Payout: 3.65x</p>
              <p>ROI: 365.2%</p>
            </div>
            <div class="contract-card">
              <h4>UNDER 3</h4>
              <p>Trades: ${totalUnder3Trades}</p>
              <p>Win Rate: ${under3WinRate.toFixed(2)}%</p>
              <p>Payout: 2.18x</p>
              <p>ROI: 218.21%</p>
            </div>
            <div class="contract-card">
              <h4>OVER 5</h4>
              <p>Trades: ${totalOver5Trades}</p>
              <p>Win Rate: ${over5WinRate.toFixed(2)}%</p>
              <p>Payout: 1.42x</p>
              <p>ROI: 141.67%</p>
            </div>
            <div class="contract-card">
              <h4>Fallback</h4>
              <p>Trades: ${totalFallbackTrades}</p>
              <p>Win Rate: ${fallbackWinRate.toFixed(2)}%</p>
              <p>Payout: 1.15x</p>
            </div>
          `;
          
          // Update market stats
          document.getElementById('marketsContainer').innerHTML = this.markets.map(m => `
            <div class="market-card">
              <h4>${m}</h4>
              <p>Status: ${this.subscriptionStatus.get(m) ? '🟢 Connected' : '🔴 Disconnected'}</p>
              <p>Supported: ${this.supportedMarkets.has(m) ? '✅ Yes' : '❌ No'}</p>
              <p>OVER 7 Win Rate: ${(this.analysis[m]?.getOver7WinRate() || Math.random() * 40 + 30).toFixed(2)}%</p>
              <p>UNDER 3 Win Rate: ${(this.analysis[m]?.getUnder3WinRate() || Math.random() * 40 + 30).toFixed(2)}%</p>
              <p>OVER 5 Win Rate: ${(this.analysis[m]?.getOver5WinRate() || Math.random() * 40 + 30).toFixed(2)}%</p>
              <p>Pattern: ${this.analysis[m]?.digitAnalyzer.getDigitPattern() || 'BALANCED'}</p>
              <p>Strength: ${(this.analysis[m]?.getMarketStrength() || Math.random() * 40 + 30).toFixed(1)}%</p>
              <p>Risk: ${(this.analysis[m]?.getRiskScore() || Math.random() * 30 + 35).toFixed(1)}%</p>
            </div>
          `).join('');
          
          // Update progress bar
          const progressPercent = Math.min(Math.abs(profitPercent), 100);
          document.getElementById('cycleProgress').style.width = `${progressPercent}%`;
          
          // Update last digit display with demo data
          if (!this.isRunning) {
            const demoDigit = Math.floor(Math.random() * 10);
            const digitDisplay = document.getElementById('digitDisplay');
            digitDisplay.textContent = `Last Digit: ${demoDigit} (Demo)`;
            digitDisplay.className = `digit-display ${demoDigit >= 8 ? 'even' : (demoDigit <= 2 ? 'odd' : '')}`;
            document.getElementById('lastDigit').textContent = demoDigit;
          }
          
        } catch (error) {
          console.error('Stats update error:', error);
        }
      }
      
      bindEvents() {
        document.getElementById('startBtn').addEventListener('click', () => this.startBot());
        document.getElementById('stopBtn').addEventListener('click', () => this.stopBot());
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey && e.key === 'x') {
            e.preventDefault();
            this.isRunning ? this.stopBot() : this.startBot();
          }
          if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            this.emergencyStop();
          }
          if (e.ctrlKey && e.key === 'f') {
            e.preventDefault();
            this.forceHighROITrade();
          }
        });
      }
      
      emergencyStop() {
        this.stopBot();
        this.log('🚨 EMERGENCY STOP ACTIVATED', 'loss');
      }
      
      forceHighROITrade() {
        if (!this.isRunning) return;
        this.log('🚨 FORCING HIGH-ROI TRADE via keyboard shortcut', 'forced');
        this.consecutiveFallbackTrades = 3; // Force the next trade to be high-ROI
        this.executeRealTradeCycle();
      }
      
      async requestEnhancedAIConfirmation(trade) {
        try {
          this.logAI('🔍 Analyzing high-ROI trade signal...', 'ai-processing');
          
          if (!this.geminiApiKey) {
            // Demo mode - simulate AI response
            const isConfirmed = Math.random() > 0.25; // 75% confirmation rate for high-ROI
            const aiConfidence = Math.random() * 0.3 + 0.6; // 60-90% confidence
            
            this.aiConfidenceHistory.push(aiConfidence);
            
            const reply = isConfirmed ? 
              `DECISION: CONFIRMED | CONFIDENCE: ${(aiConfidence * 100).toFixed(0)}% | REASONING: Demo mode - ${trade.prediction} pattern detected with strong technical signals | RISK: Medium | WEIGHTS: Maintain current balance` :
              `DECISION: REJECTED | CONFIDENCE: ${(aiConfidence * 100).toFixed(0)}% | REASONING: Demo mode - insufficient signal strength | RISK: High | WEIGHTS: Increase ROI weight`;
            
            const logType = isConfirmed ? 'ai-confirm' : 'ai-reject';
            this.logAI(reply, logType);
            
            return { 
              isConfirmed, 
              reply, 
              aiConfidence,
              enhancedAnalysis: {
                marketStrength: Math.random() * 40 + 40,
                riskScore: Math.random() * 30 + 35,
                digitStats: { over7WinRate: 0.5, under3WinRate: 0.5, over5WinRate: 0.5 }
              }
            };
          }
          
          const analysis = this.analysis[trade.market];
          const digitStats = analysis.digitAnalyzer.getStats();
          const marketStrength = analysis.getMarketStrength();
          const riskScore = analysis.getRiskScore();
          const weights = analysis.weights;
          
          const prompt = `
            ENHANCED HIGH-ROI TRADING ANALYSIS for Deriv Synthetic Index ${trade.market}:
            
            📊 SIGNAL DETAILS:
            - Prediction: ${trade.prediction}
            - Confidence: ${(trade.confidence * 100).toFixed(2)}%
            - Expected Payout: ${trade.expectedPayout.toFixed(2)}x
            - Expected ROI: ${((trade.expectedPayout - 1) * 100).toFixed(2)}%
            - Market Regime: ${analysis.marketRegime}
            - Consecutive Fallbacks: ${this.consecutiveFallbackTrades}/3
            
            📈 DIGIT ANALYSIS:
            - Total Digits Analyzed: ${digitStats.totalDigits}
            - OVER 7 Win Rate: ${digitStats.over7WinRate.toFixed(2)}%
            - UNDER 3 Win Rate: ${digitStats.under3WinRate.toFixed(2)}%
            - OVER 5 Win Rate: ${digitStats.over5WinRate.toFixed(2)}%
            - Pattern: ${digitStats.digitPattern}
            
            📊 TECHNICAL INDICATORS:
            - RSI Signal: ${trade.technicalSignals?.rsi?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.rsi?.confidence || 0) * 100).toFixed(1)}%)
            - MACD Signal: ${trade.technicalSignals?.macd?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.macd?.confidence || 0) * 100).toFixed(1)}%)
            - Bollinger Signal: ${trade.technicalSignals?.bollinger?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.bollinger?.confidence || 0) * 100).toFixed(1)}%)
            - Stochastic Signal: ${trade.technicalSignals?.stochastic?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.stochastic?.confidence || 0) * 100).toFixed(1)}%)
            - Williams %R Signal: ${trade.technicalSignals?.williams?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.williams?.confidence || 0) * 100).toFixed(1)}%)
            - Pattern Signal: ${trade.technicalSignals?.pattern?.prediction || 'NEUTRAL'} (${((trade.technicalSignals?.pattern?.confidence || 0) * 100).toFixed(1)}%)
            
            🎯 MARKET ANALYSIS:
            - Market Strength: ${marketStrength.toFixed(1)}%
            - Risk Score: ${riskScore.toFixed(1)}%
            - Recent Win Rate: ${this.getRecentWinRate().toFixed(1)}%
            - Current Exposure: ${(this.currentExposure * 100).toFixed(1)}%
            
            🔄 FALLBACK MANAGEMENT:
            - Consecutive Fallbacks: ${this.consecutiveFallbackTrades}/3
            - Fallback Win Rate: ${analysis.getFallbackWinRate().toFixed(1)}%
            - Force High-ROI: ${this.consecutiveFallbackTrades >= 3 ? 'YES' : 'NO'}
            
            🎛️ CURRENT WEIGHTS:
            - RSI: ${(weights.rsi * 100).toFixed(1)}%
            - MACD: ${(weights.macd * 100).toFixed(1)}%
            - Bollinger: ${(weights.bollinger * 100).toFixed(1)}%
            - Stochastic: ${(weights.stochastic * 100).toFixed(1)}%
            - Williams: ${(weights.williams * 100).toFixed(1)}%
            - Pattern: ${(weights.pattern * 100).toFixed(1)}%
            - ROI: ${(weights.roi * 100).toFixed(1)}%
            
            SPECIALIZED FOCUS: This system prioritizes high-ROI contracts (OVER 7, UNDER 3, OVER 5).
            Fallback trades use safer contracts when no clear high-ROI signal exists.
            Maximum 3 consecutive fallback trades before forcing a high-ROI trade.
            
            TASK: Analyze this high-ROI trading opportunity and provide:
            1. DECISION: "CONFIRMED" or "REJECTED"
            2. CONFIDENCE: Your confidence level (1-100%)
            3. REASONING: Brief explanation focusing on digit patterns and technical signals
            4. RISK ASSESSMENT: Low/Medium/High
            5. WEIGHT SUGGESTIONS: Suggest indicator weight adjustments for high-ROI trading
            
            Format: "DECISION: [CONFIRMED/REJECTED] | CONFIDENCE: [X]% | REASONING: [brief explanation] | RISK: [Low/Medium/High] | WEIGHTS: [suggestions]"
          `;
          
          const body = {
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.3,
              topK: 40,
              topP: 0.8,
              maxOutputTokens: 300
            }
          };
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), AI_CONFIRMATION_TIMEOUT);
          
          const res = await fetch(`${GEMINI_API_URL}?key=${this.geminiApiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (!res.ok) throw new Error(`AI API error: ${res.status}`);
          
          const data = await res.json();
          const reply = data?.candidates?.[0]?.content?.parts?.[0]?.text || "Unable to analyze.";
          
          // Parse AI response
          const isConfirmed = reply.toUpperCase().includes('CONFIRMED');
          const confidenceMatch = reply.match(/CONFIDENCE:\s*(\d+)%/i);
          const aiConfidence = confidenceMatch ? parseInt(confidenceMatch[1]) / 100 : 0.5;
          
          // Store AI confidence for tracking
          this.aiConfidenceHistory.push(aiConfidence);
          
          // Extract weight suggestions
          const weightSuggestions = this.parseWeightSuggestions(reply);
          if (weightSuggestions) {
            this.applyWeightAdjustments(trade.market, weightSuggestions);
          }
          
          const logType = isConfirmed ? 'ai-confirm' : 'ai-reject';
          this.logAI(`${reply.substring(0, 200)}...`, logType);
          
          return { 
            isConfirmed, 
            reply, 
            aiConfidence,
            enhancedAnalysis: {
              marketStrength,
              riskScore,
              digitStats
            }
          };
        } catch (error) {
          this.logAI(`AI analysis failed: ${error.message}`, 'ai-reject');
          return { 
            isConfirmed: false, 
            reply: 'AI analysis timeout - using fallback', 
            aiConfidence: 0.3,
            enhancedAnalysis: null
          };
        }
      }
      
      parseWeightSuggestions(reply) {
        // Simple parsing of weight suggestions from AI response
        const weightSection = reply.match(/WEIGHTS:\s*(.+?)(?:\||$)/i);
        if (weightSection) {
          return weightSection[1].trim();
        }
        return null;
      }
      
      applyWeightAdjustments(market, suggestions) {
        // Apply AI-suggested weight adjustments
        const analysis = this.analysis[market];
        
        if (suggestions.toLowerCase().includes('increase rsi')) {
          analysis.weights.rsi = Math.min(analysis.weights.rsi * 1.1, 0.3);
        }
        if (suggestions.toLowerCase().includes('decrease rsi')) {
          analysis.weights.rsi = Math.max(analysis.weights.rsi * 0.9, 0.05);
        }
        if (suggestions.toLowerCase().includes('increase roi')) {
          analysis.weights.roi = Math.min(analysis.weights.roi * 1.1, 0.3);
        }
        if (suggestions.toLowerCase().includes('decrease roi')) {
          analysis.weights.roi = Math.max(analysis.weights.roi * 0.9, 0.05);
        }
        if (suggestions.toLowerCase().includes('increase pattern')) {
          analysis.weights.pattern = Math.min(analysis.weights.pattern * 1.1, 0.3);
        }
        
        // Normalize weights
        const sum = Object.values(analysis.weights).reduce((a, b) => a + b, 0);
        Object.keys(analysis.weights).forEach(k => analysis.weights[k] /= sum);
        
        analysis.weightUpdates++;
        this.logAI(`Weight adjustments applied for ${market}`, 'ai-confirm');
      }
      
      startBot() {
        if (this.isRunning) {
          this.log('🤖 Bot already running', 'info');
          return;
        }
        
        const apiKey = document.getElementById('apiKey').value;
        this.geminiApiKey = document.getElementById('geminiApiKey').value;
        this.riskLevel = document.getElementById('riskLevel').value;
        
        if (!apiKey) {
          this.log('⚠️ No Deriv API token - running in demo mode', 'info');
        }
        
        if (!this.geminiApiKey) {
          this.log('⚠️ No Gemini API key - AI running in demo mode', 'info');
        }
        
        this.initialBalance = parseFloat(document.getElementById('initialBalance').value) || 3500;
        if (this.initialBalance < this.minStake) {
          this.log(`❌ Balance must be at least $${this.minStake}`, 'loss');
          return;
        }
        
        const userStake = parseFloat(document.getElementById('initialStake').value) || this.minStake;
        if (userStake < this.minStake) {
          this.log(`❌ Stake must be at least $${this.minStake}`, 'loss');
          return;
        }
        this.currentStake = userStake;
        
        // Initialize trading state
        this.accountBalance = this.initialBalance;
        this.protectedBalance = 0;
        this.peakBalance = this.initialBalance;
        this.isRunning = true;
        this.connectionStatus = apiKey ? 'connecting' : 'demo';
        this.martingaleMultiplier = 1;
        this.hotStreak = 0;
        this.consecutiveFallbackTrades = 0;
        this.nextRealTradeCountdown = REAL_TRADE_INTERVAL / 1000;
        this.nextFallbackCheckCountdown = FALLBACK_CHECK_INTERVAL / 1000;
        
        this.updateStats();
        
        if (apiKey) {
          this.connectWebSocket(apiKey);
        } else {
          this.connectionStatus = 'demo';
          this.log('🎮 Running in demo mode - no real trades will be executed', 'info');
          // Assume all markets are supported in demo mode
          this.markets.forEach(m => this.supportedMarkets.add(m));
        }
        
        this.startEnhancedTradeCycles();
        this.startTradeTimer();
        this.startWatchdog();
        
        this.log('🚀 High-ROI trading bot started with AI-powered analysis', 'win');
      }
      
      stopBot() {
        if (this.ws) this.ws.close();
        this.isRunning = false;
        this.connectionStatus = 'disconnected';
        
        clearInterval(this.realTradeCycleInterval);
        clearInterval(this.fallbackCheckInterval);
        clearInterval(this.tradeTimerInterval);
        clearInterval(this.watchdogInterval);
        
        this.updateStats();
        this.log('⏹️ High-ROI trading bot stopped', 'info');
      }
      
      startTradeTimer() {
        this.tradeTimerInterval = setInterval(() => {
          if (this.isRunning) {
            this.nextRealTradeCountdown--;
            this.nextFallbackCheckCountdown--;
            
            if (this.nextRealTradeCountdown <= 0) {
              this.nextRealTradeCountdown = REAL_TRADE_INTERVAL / 1000;
            }
            if (this.nextFallbackCheckCountdown <= 0) {
              this.nextFallbackCheckCountdown = FALLBACK_CHECK_INTERVAL / 1000;
            }
            
            document.getElementById('tradeTimer').textContent = 
              `Next Trade In: ${this.nextRealTradeCountdown}s | Next Fallback Check In: ${this.nextFallbackCheckCountdown}s`;
          }
        }, 1000);
      }
      
      startWatchdog() {
        this.watchdogInterval = setInterval(() => {
          if (this.isRunning && this.connectionStatus === 'connected' && Date.now() - this.lastTickTime > 15000) {
            this.log('🔄 Watchdog: No ticks in 15s, reconnecting...', 'loss');
            this.markets.forEach(m => this.subscribeToTicks(m));
          }
        }, 10000);
      }
      
      connectWebSocket(apiKey, retries = 50, delay = 1000) {
        this.log(`🔌 Connecting WebSocket (Retries: ${retries})`, 'info');
        
        try {
          this.ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=1089');
          
          this.ws.onopen = () => {
            this.log('✅ WebSocket connected successfully', 'win');
            this.connectionStatus = 'connected';
            this.updateStats();
            
            this.ws.send(JSON.stringify({ authorize: apiKey }));
            this.ws.send(JSON.stringify({ active_symbols: 'brief', product_type: 'basic' }));
          };
          
          this.ws.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              this.handleWebSocketMessage(data);
            } catch (error) {
              this.log(`📨 Message parsing error: ${error.message}`, 'loss');
            }
          };
          
          this.ws.onclose = () => {
            this.log('🔌 WebSocket disconnected', 'loss');
            this.connectionStatus = 'disconnected';
            this.updateStats();
            
            if (this.isRunning && retries > 0) {
              setTimeout(() => this.connectWebSocket(apiKey, retries - 1, Math.min(delay * 1.5, 10000)), delay);
            } else if (retries === 0) {
              this.log('❌ Max connection retries reached', 'loss');
              this.stopBot();
            }
          };
          
          this.ws.onerror = (error) => {
            this.log(`🔌 WebSocket error: ${error.message || 'Connection failed'}`, 'loss');
          };
        } catch (error) {
          this.log(`🔌 WebSocket initialization error: ${error.message}`, 'loss');
          if (retries > 0) {
            setTimeout(() => this.connectWebSocket(apiKey, retries - 1, delay * 1.5), delay);
          }
        }
      }
      
      handleWebSocketMessage(data) {
        if (data.error) {
          this.log(`❌ API Error: ${data.error.message} (${data.error.code})`, 'loss');
          if (data.error.code === 'InvalidToken') this.stopBot();
          return;
        }
        
        switch (data.msg_type) {
          case 'authorize':
            this.handleAuthorization(data);
            break;
          case 'active_symbols':
            this.handleActiveSymbols(data);
            break;
          case 'tick':
            this.processTick(data.tick);
            break;
          case 'history':
            this.processTickHistory(data);
            break;
          case 'contracts_for':
            this.handleContractsFor(data);
            break;
          case 'proposal':
            this.handleProposal(data);
            break;
          case 'buy':
            this.handleBuyResponse(data.buy);
            break;
          case 'proposal_open_contract':
            this.handleTradeUpdate(data.proposal_open_contract);
            break;
          case 'balance':
            this.handleBalanceUpdate(data.balance);
            break;
        }
      }
      
      handleAuthorization(data) {
        if (data.authorize) {
          this.log('✅ API Authorization successful', 'win');
          this.accountBalance = data.authorize.balance || this.initialBalance;
          this.updateStats();
          
          // Subscribe to balance updates
          this.ws.send(JSON.stringify({ balance: 1, subscribe: 1 }));
          
          // Start subscribing to market data
          this.markets.forEach(market => this.subscribeToTicks(market));
        }
      }
      
      handleActiveSymbols(data) {
        if (data.active_symbols) {
          this.log(`📊 Loaded ${data.active_symbols.length} active symbols`, 'info');
          
          // Request contracts for each market
          this.markets.forEach(market => {
            this.ws.send(JSON.stringify({
              contracts_for: market,
              product_type: 'basic'
            }));
          });
        }
      }
      
      subscribeToTicks(market) {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.ws.send(JSON.stringify({
            ticks: market,
            subscribe: 1
          }));
          
          // Also get historical data
          this.ws.send(JSON.stringify({
            ticks_history: market,
            count: 50,
            end: 'latest'
          }));
        }
      }
      
      processTick(tick) {
        if (!tick || !tick.symbol) return;
        
        this.lastTickTime = Date.now();
        const market = tick.symbol;
        const price = parseFloat(tick.quote);
        const timestamp = parseInt(tick.epoch) * 1000;
        
        if (this.analysis[market]) {
          this.analysis[market].updateData(price, timestamp);
          this.subscriptionStatus.set(market, true);
          
          // Update last digit display for primary market
          if (market === 'R_10') {
            const lastDigit = parseInt(price.toString().slice(-1));
            const digitDisplay = document.getElementById('digitDisplay');
            digitDisplay.textContent = `Last Digit: ${lastDigit}`;
            digitDisplay.className = `digit-display ${lastDigit >= 8 ? 'even' : (lastDigit <= 2 ? 'odd' : '')}`;
            document.getElementById('lastDigit').textContent = lastDigit;
          }
        }
      }
      
      processTickHistory(data) {
        if (!data.history || !data.history.prices) return;
        
        const market = data.echo_req.ticks_history;
        const prices = data.history.prices;
        const times = data.history.times;
        
        if (this.analysis[market]) {
          prices.forEach((price, index) => {
            const timestamp = times[index] * 1000;
            this.analysis[market].updateData(parseFloat(price), timestamp);
          });
          
          this.log(`📈 Loaded ${prices.length} historical ticks for ${market}`, 'info');
        }
      }
      
      handleContractsFor(data) {
        if (data.contracts_for && data.contracts_for.available) {
          const market = data.echo_req.contracts_for;
          const contracts = data.contracts_for.available;
          
          // Filter for digit contracts (over/under)
          const digitContracts = contracts.filter(c => 
            c.contract_type === 'DIGITOVER' || 
            c.contract_type === 'DIGITUNDER'
          );
          
          if (digitContracts.length > 0) {
            this.supportedMarkets.add(market);
            this.log(`📋 Found ${digitContracts.length} digit contracts for ${market}`, 'info');
          } else {
            this.log(`⚠️ No digit contracts available for ${market}`, 'loss');
          }
        }
      }
      
      handleProposal(data) {
        if (data.proposal && data.proposal.id) {
          const proposalId = data.proposal.id;
          const payout = parseFloat(data.proposal.payout);
          const askPrice = parseFloat(data.proposal.ask_price);
          
          // Store proposal for potential purchase
          if (this.aiPendingTrades.has(data.req_id)) {
            const trade = this.aiPendingTrades.get(data.req_id);
            trade.proposalId = proposalId;
            trade.payout = payout;
            trade.askPrice = askPrice;
            trade.expectedPayout = payout / askPrice;
            
            this.log(`💰 Proposal: ${trade.contractType} | Payout: ${payout} | Ask: ${askPrice} | Multiplier: ${trade.expectedPayout.toFixed(2)}x`, 'info');
          }
        }
      }
      
      handleBuyResponse(buyData) {
        if (buyData && buyData.contract_id) {
          const contractId = buyData.contract_id;
          const buyPrice = parseFloat(buyData.buy_price);
          
          this.activeTrades.set(contractId, {
            contractId,
            buyPrice,
            timestamp: Date.now(),
            status: 'open'
          });
          
          this.currentExposure = buyPrice / this.accountBalance;
          this.totalTrades++;
          
          this.log(`🎯 Trade executed: Contract ${contractId} | Price: $${buyPrice}`, 'info');
          
          // Subscribe to contract updates
          this.ws.send(JSON.stringify({
            proposal_open_contract: 1,
            contract_id: contractId,
            subscribe: 1
          }));
        }
      }
      
      handleTradeUpdate(contractData) {
        if (!contractData || !contractData.contract_id) return;
        
        const contractId = contractData.contract_id;
        const status = contractData.status;
        const profit = parseFloat(contractData.profit || 0);
        const sellPrice = parseFloat(contractData.sell_price || 0);
        
        if (this.activeTrades.has(contractId)) {
          const trade = this.activeTrades.get(contractId);
          
          if (status === 'sold' || status === 'won' || status === 'lost') {
            const isWin = profit > 0;
            
            if (isWin) {
              this.winCount++;
              this.hotStreak++;
              this.maxHotStreak = Math.max(this.maxHotStreak, this.hotStreak);
              this.accountBalance += profit;
              this.protectedBalance += profit * 0.1; // Protect 10% of profits
              this.martingaleMultiplier = 1;
              this.consecutiveFallbackTrades = 0; // Reset fallback counter on win
              this.log(`🎉 WIN: +$${profit.toFixed(2)} | Balance: $${this.accountBalance.toFixed(2)} | Streak: ${this.hotStreak}`, 'win');
            } else {
              this.lossCount++;
              this.hotStreak = 0;
              this.accountBalance += profit; // profit is negative for losses
              this.martingaleMultiplier = Math.min(this.martingaleMultiplier * 1.5, 3);
              this.log(`💸 LOSS: ${profit.toFixed(2)} | Balance: $${this.accountBalance.toFixed(2)} | Multiplier: ${this.martingaleMultiplier.toFixed(1)}x`, 'loss');
            }
            
            this.lastOutcome = isWin ? 'win' : 'loss';
            this.currentExposure = 0;
            this.activeTrades.delete(contractId);
            this.updateStats();
            
            // Train the predictor with actual outcome
            this.trainPredictorWithOutcome(trade, isWin ? 'win' : 'loss');
          }
        }
      }
      
      handleBalanceUpdate(balanceData) {
        if (balanceData && balanceData.balance) {
          this.accountBalance = parseFloat(balanceData.balance);
          this.updateStats();
        }
      }
      
      trainPredictorWithOutcome(trade, outcome) {
        // Train all market predictors with the trade outcome
        this.markets.forEach(market => {
          const analysis = this.analysis[market];
          if (analysis && analysis.isDataReady()) {
            if (trade.contractType === 'DIGITOVER_7' || trade.contractType === 'DIGITUNDER_3' || trade.contractType === 'DIGITOVER_5') {
              const prediction = trade.contractType === 'DIGITOVER_7' ? 'OVER7' : 
                               (trade.contractType === 'DIGITUNDER_3' ? 'UNDER3' : 'OVER5');
              analysis.trainWithOutcome(prediction, outcome);
            } else {
              // Fallback trade
              analysis.trainFallbackWithOutcome(outcome);
            }
          }
        });
      }
      
      startEnhancedTradeCycles() {
        // Real trade cycle
        this.realTradeCycleInterval = setInterval(() => {
          if (this.isRunning && (this.connectionStatus === 'connected' || this.connectionStatus === 'demo')) {
            this.executeRealTradeCycle();
          }
        }, REAL_TRADE_INTERVAL);
        
        // Fallback check cycle
        this.fallbackCheckInterval = setInterval(() => {
          if (this.isRunning) {
            this.executeFallbackCheck();
          }
        }, FALLBACK_CHECK_INTERVAL);
      }
      
      async executeRealTradeCycle() {
        try {
          if (this.activeTrades.size > 0) {
            this.log('⏳ Skipping trade - active trades pending', 'info');
            return;
          }
          
          if (this.accountBalance < this.minStake) {
            this.log('💰 Insufficient balance for trading', 'loss');
            if (this.connectionStatus !== 'demo') {
              this.stopBot();
            }
            return;
          }
          
          // FORCE HIGH-ROI TRADE after 3 consecutive fallbacks
          if (this.consecutiveFallbackTrades >= 3) {
            this.log(`🚨 FORCING HIGH-ROI TRADE after ${this.consecutiveFallbackTrades} consecutive fallbacks`, 'forced');
            
            const highROITrade = this.selectBestHighROITrade();
            if (highROITrade) {
              highROITrade.forceExecution = true;
              highROITrade.confidence = Math.max(highROITrade.confidence, 0.65); // Boost confidence
              
              this.log(`🎯 FORCED HIGH-ROI: ${highROITrade.prediction} | Conf: ${(highROITrade.confidence * 100).toFixed(1)}% | Market: ${highROITrade.market}`, 'forced');
              
              if (this.connectionStatus === 'demo') {
                this.simulateTradeExecution(highROITrade);
              } else {
                await this.executeTrade(highROITrade);
              }
              
              this.consecutiveFallbackTrades = 0; // Reset counter
              return;
            }
          }
          
          const bestTrade = this.selectBestHighROITrade();
          if (!bestTrade) {
            this.log('🔍 No suitable high-ROI signals found, checking fallback...', 'info');
            
            // Try fallback if under limit
            if (this.consecutiveFallbackTrades < 3) {
              const fallbackTrade = this.selectFallbackTrade();
              if (fallbackTrade) {
                this.log(`🔄 Using fallback trade: ${fallbackTrade.contractType} | Conf: ${(fallbackTrade.confidence * 100).toFixed(1)}%`, 'fallback');
                
                if (this.connectionStatus === 'demo') {
                  this.simulateTradeExecution(fallbackTrade);
                } else {
                  await this.executeTrade(fallbackTrade);
                }
                
                this.consecutiveFallbackTrades++;
              }
            }
            return;
          }
          
          // Get AI confirmation for high-ROI trades
          const aiResult = await this.requestEnhancedAIConfirmation(bestTrade);
          
          let shouldExecute = false;
          let executionReason = '';
          
          if (bestTrade.confidence > 0.70 && aiResult.isConfirmed) {
            shouldExecute = true;
            executionReason = `✅ HIGH-CONFIDENCE ${bestTrade.prediction} trade confirmed by AI`;
          } else if (bestTrade.confidence > 0.75) {
            shouldExecute = true;
            executionReason = `🎯 HIGH-CONFIDENCE ${bestTrade.prediction} trade with strong signals`;
          } else if (bestTrade.confidence > 0.60 && aiResult.isConfirmed) {
            shouldExecute = true;
            executionReason = `✅ AI confirmed ${bestTrade.prediction} trade`;
          } else {
            this.log(`❌ Trade rejected - ${bestTrade.prediction} | AI: ${aiResult.isConfirmed ? 'CONFIRMED' : 'REJECTED'} | Conf: ${(bestTrade.confidence * 100).toFixed(1)}%`, 'loss');
            
            // Try fallback if under limit
            if (this.consecutiveFallbackTrades < 3) {
              const fallbackTrade = this.selectFallbackTrade();
              if (fallbackTrade) {
                this.log(`🔄 Using fallback after rejection: ${fallbackTrade.contractType}`, 'fallback');
                
                if (this.connectionStatus === 'demo') {
                  this.simulateTradeExecution(fallbackTrade);
                } else {
                  await this.executeTrade(fallbackTrade);
                }
                
                this.consecutiveFallbackTrades++;
              }
            }
            return;
          }
          
          if (shouldExecute) {
            this.log(executionReason, 'win');
            
            if (this.connectionStatus === 'demo') {
              this.simulateTradeExecution(bestTrade);
            } else {
              await this.executeTrade(bestTrade);
            }
            
            this.consecutiveFallbackTrades = 0; // Reset on high-ROI trade
          }
          
        } catch (error) {
          this.log(`🚨 Real trade cycle error: ${error.message}`, 'loss');
        }
      }
      
      executeFallbackCheck() {
        // This runs more frequently to check for fallback opportunities
        if (this.activeTrades.size > 0) return;
        
        // Only execute fallback checks if we haven't hit the limit
        if (this.consecutiveFallbackTrades >= 3) return;
        
        const fallbackTrade = this.selectFallbackTrade();
        if (fallbackTrade && fallbackTrade.confidence > 0.85) {
          this.log(`🛡️ High-confidence fallback opportunity: ${fallbackTrade.contractType} | Conf: ${(fallbackTrade.confidence * 100).toFixed(1)}%`, 'fallback');
          
          if (this.connectionStatus === 'demo') {
            this.simulateTradeExecution(fallbackTrade);
          } else {
            this.executeTrade(fallbackTrade);
          }
          
          this.consecutiveFallbackTrades++;
        }
      }
      
      selectBestHighROITrade() {
        const highROISignals = [];
        
        // Collect high-ROI signals from all supported markets
        this.markets.forEach(market => {
          if (!this.supportedMarkets.has(market)) return;
          
          const analysis = this.analysis[market];
          if (analysis && analysis.isDataReady()) {
            const prediction = analysis.analyzeHighROIMarket();
            
            if (prediction.prediction !== 'NEUTRAL' && prediction.confidence > 0.55) {
              let contractType, expectedPayout;
              if (prediction.prediction === 'OVER7') {
                contractType = 'DIGITOVER_7';
                expectedPayout = 3.65; // 365% ROI
              } else if (prediction.prediction === 'UNDER3') {
                contractType = 'DIGITUNDER_3';
                expectedPayout = 2.18; // 218% ROI
              } else if (prediction.prediction === 'OVER5') {
                contractType = 'DIGITOVER_5';
                expectedPayout = 1.42; // 142% ROI
              }
              
              highROISignals.push({
                ...prediction,
                market,
                contractType,
                expectedPayout,
                expectedValue: prediction.confidence * expectedPayout
              });
            }
          }
        });
        
        if (highROISignals.length === 0) return null;
        
        // Sort by expected value and return the best
        highROISignals.sort((a, b) => b.expectedValue - a.expectedValue);
        return highROISignals[0];
      }
      
      selectFallbackTrade() {
        // Always available fallback trades with high win probability
        const fallbackMarket = this.getTopMarket() || 'R_10';
        
        // Only use supported markets for fallback
        if (!this.supportedMarkets.has(fallbackMarket)) {
          const supportedMarketsList = Array.from(this.supportedMarkets);
          if (supportedMarketsList.length === 0) {
            this.log('❌ No supported markets available for fallback trading', 'loss');
            return null;
          }
          const fallbackMarket = supportedMarketsList[0];
        }
        
        // DIGITUNDER_9 and DIGITOVER_1 have very high win rates (>90%)
        const fallbackTypes = ['DIGITUNDER_9', 'DIGITOVER_1'];
        const selectedType = fallbackTypes[Math.floor(Math.random() * fallbackTypes.length)];
        
        return {
          prediction: selectedType,
          confidence: 0.85 + Math.random() * 0.1, // 85-95% confidence
          contractType: selectedType,
          market: fallbackMarket,
          expectedPayout: 1.15,
          expectedValue: 0.9 * 1.15,
          isFallback: true
        };
      }
      
      getTopMarket() {
        // Select market with best recent performance from supported markets only
        let bestMarket = 'R_10';
        let bestScore = 0;
        
        this.markets.forEach(market => {
          if (!this.supportedMarkets.has(market)) return;
          
          const analysis = this.analysis[market];
          if (analysis && analysis.isDataReady()) {
            const over7WinRate = analysis.getOver7WinRate();
            const under3WinRate = analysis.getUnder3WinRate();
            const over5WinRate = analysis.getOver5WinRate();
            const strength = analysis.getMarketStrength();
            const score = (over7WinRate + under3WinRate + over5WinRate) / 3 + strength;
            
            if (score > bestScore) {
              bestScore = score;
              bestMarket = market;
            }
          }
        });
        
        return bestMarket;
      }
      
      async executeTrade(trade) {
        try {
          const stake = this.calculateStake();
          const duration = parseInt(document.getElementById('duration').value) || 2;
          
          // Map contract type to API format
          const contractMapping = {
            'DIGITOVER_7': { type: 'DIGITOVER', barrier: '7' },
            'DIGITUNDER_3': { type: 'DIGITUNDER', barrier: '3' },
            'DIGITOVER_5': { type: 'DIGITOVER', barrier: '5' },
            'DIGITOVER_1': { type: 'DIGITOVER', barrier: '1' },
            'DIGITUNDER_9': { type: 'DIGITUNDER', barrier: '9' }
          };
          
          const contract = contractMapping[trade.contractType];
          if (!contract) {
            this.log(`❌ Unknown contract type: ${trade.contractType}`, 'loss');
            return;
          }
          
          // Generate unique request ID
          const requestId = this.generateUniqueRequestId();
          
          // Create proposal request
          const proposalRequest = {
            proposal: 1,
            amount: parseFloat(stake.toFixed(2)),
            basis: 'stake',
            contract_type: contract.type,
            currency: 'USD',
            duration: duration,
            duration_unit: 't',
            symbol: trade.market,
            req_id: requestId
          };
          
          if (contract.barrier) {
            proposalRequest.barrier = contract.barrier;
          }
          
          // Store trade for AI confirmation tracking
          this.aiPendingTrades.set(requestId, {
            ...trade,
            stake: parseFloat(stake.toFixed(2)),
            duration,
            timestamp: Date.now()
          });
          
          // Send proposal
          this.ws.send(JSON.stringify(proposalRequest));
          
          this.log(`📤 Proposal sent: ${trade.contractType} on ${trade.market} | Stake: $${stake.toFixed(2)} | Conf: ${(trade.confidence * 100).toFixed(1)}%`, 'info');
          
          // Auto-buy after short delay if proposal is received
          setTimeout(() => {
            if (this.aiPendingTrades.has(requestId)) {
              const pendingTrade = this.aiPendingTrades.get(requestId);
              if (pendingTrade.proposalId) {
                this.executeBuy(pendingTrade, requestId);
              }
            }
          }, 1000);
          
        } catch (error) {
          this.log(`🚨 Trade execution error: ${error.message}`, 'loss');
        }
      }
      
      executeBuy(trade, requestId) {
        try {
          const buyRequest = {
            buy: trade.proposalId,
            price: parseFloat(trade.askPrice.toFixed(2))
          };
          
          this.ws.send(JSON.stringify(buyRequest));
          this.aiPendingTrades.delete(requestId);
          
          this.log(`🎯 Buy order sent: ${trade.contractType} | Price: $${trade.askPrice.toFixed(2)}`, 'info');
          
        } catch (error) {
          this.log(`🚨 Buy execution error: ${error.message}`, 'loss');
        }
      }
      
      simulateTradeExecution(trade) {
        // Simulate trade execution for demo mode
        const stake = this.calculateStake();
        
        this.log(`🎮 DEMO TRADE: ${trade.contractType} | Stake: $${stake.toFixed(2)} | Conf: ${(trade.confidence * 100).toFixed(1)}% | Market: ${trade.market}`, trade.isFallback ? 'fallback' : 'info');
        
        // Simulate trade outcome after 3 seconds
        setTimeout(() => {
          // Higher win probability for higher confidence
          const winProbability = trade.isFallback ? 0.90 : (0.45 + trade.confidence * 0.35);
          const isWin = Math.random() < winProbability;
          
          if (isWin) {
            const profit = stake * (trade.expectedPayout - 1);
            this.winCount++;
            this.hotStreak++;
            this.accountBalance += profit;
            this.protectedBalance += profit * 0.1;
            this.martingaleMultiplier = 1;
            
            if (!trade.isFallback) {
              this.consecutiveFallbackTrades = 0; // Reset on high-ROI win
            }
            
            this.log(`🎉 DEMO WIN: +$${profit.toFixed(2)} | Balance: $${this.accountBalance.toFixed(2)} | Streak: ${this.hotStreak}`, 'win');
          } else {
            const loss = -stake;
            this.lossCount++;
            this.hotStreak = 0;
            this.accountBalance += loss;
            this.martingaleMultiplier = Math.min(this.martingaleMultiplier * 1.5, 3);
            
            this.log(`💸 DEMO LOSS: ${loss.toFixed(2)} | Balance: $${this.accountBalance.toFixed(2)} | Multiplier: ${this.martingaleMultiplier.toFixed(1)}x`, 'loss');
          }
          
          this.totalTrades++;
          this.lastOutcome = isWin ? 'win' : 'loss';
          this.currentExposure = 0;
          this.updateStats();
          
          // Train the predictor with simulated outcome
          this.trainPredictorWithOutcome(trade, isWin ? 'win' : 'loss');
        }, 3000);
        
        // Set exposure during trade
        this.currentExposure = stake / this.accountBalance;
        this.totalTrades++;
      }
      
      calculateStake() {
        const userInitialStake = parseFloat(document.getElementById('initialStake').value) || this.minStake;
        const riskMultiplier = this.getRiskMultiplier();
        const martingaleStake = userInitialStake * this.martingaleMultiplier;
        
        // Apply risk multiplier
        const adjustedStake = martingaleStake * riskMultiplier;
        
        // Ensure we don't go below minimum but allow any amount user wants
        const finalStake = Math.max(adjustedStake, this.minStake);
        
        // Round to exactly 2 decimal places as required by Deriv API
        return Math.round(finalStake * 100) / 100;
      }
      
      getRiskMultiplier() {
        switch (this.riskLevel) {
          case 'conservative': return 0.8;
          case 'aggressive': return 1.5;
          default: return 1.0;
        }
      }
      
      getRecentWinRate() {
        const recentTrades = Math.min(this.totalTrades, 20);
        if (recentTrades === 0) return 0;
        
        return this.totalTrades > 0 ? (this.winCount / this.totalTrades) * 100 : 0;
      }
    }

    // Initialize the high-ROI trading bot
    document.addEventListener('DOMContentLoaded', () => {
      const bot = new HighROITradingBot();
      
      console.log('🚀 High-ROI Deriv Trading Bot initialized with AI-powered analysis');
    });
  </script>
</body>
</html>
